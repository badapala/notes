# 一致性Hash(Consistent Hashing)



## 一、 经典哈希方法

### 1、简介

Hashing，也称作散列，是通过某种特定的函数/算法（散列函数/算法）将需要检索项与检索的索引关联起来，生成一种便于搜索的数据结构。确保计算机程序所需的资源能够高效地存储在内存中，从而使内存中的数据结构均匀地加载。

哈希函数（Hash Function），也称为散列函数或杂凑函数。哈希函数是一个公开函数，可以将任意长度的消息`M`映射成为一个长度较短且长度固定的值`H（M）`，称`H（M）`为哈希值、散列值`（Hash Value）`、杂凑值或者消息摘要`（Message Digest）`。它是一种单向密码体制，即一个从明文到密文的不可逆映射，只有加密过程，没有解密过程。所有散列函数都有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“散列碰撞（collision）”，这通常是两个不同长度的输入值，刻意计算出相同的输出值。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。

一个可靠的哈希算法，应该满足：

- 对于给定的数据`M` ,很容易算出哈希值 `X=F(M) `;
- 根据X很难反算出`M`;
- 很难找到 `M` 和 `N` 使得 `F(N) = F(M)` 

在缓存服务的适用场景一般是缓存环境不怎么发生变化，对于缓存服务器群的稳定性要求较高。一旦服务器群出现故障，就有可能导致井喷现象，出现缓存服务瞬间崩溃。

## 2、常见的哈希算法



## 二、 一致性哈希

一致性哈希是麻省理工学院提出的一种分布式哈希（DHT）实现算法算法，目前主要应用于分布式缓存当中，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。一致性哈希可以有效地解决分布式存储结构下动态增加和删除节点所带来的问题。

### 1、原理

#### a. 环形hash 空间

普通的哈希算法是hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32-1 次方的数值空间，那么在一致性哈希中，可以将全量的缓存空间组织成一个虚拟的环形存储结构(HashRing)。假设某哈希函数H的值空间为0-2^32-1，（即哈希值是一个32位无符号整形）。整个哈希空间环按顺时针方向组织，0和232-1在零点中方向重合则此虚拟环是一个首（ 0 ）尾（ 2^32-1 ）相接的圆环，共分成2^32个缓存区。

#### b. 把对象映射到hash 空间

每一个缓存key都可以通过Hash算法转化为一个32位的二进制数，也就对应着环形空间的某一个缓存区。我们把所有的缓存key映射到环形空间的不同位置。

#### c. 把cache 映射到hash 空间

Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，且使用同样的HASH算法。

#### d. 把对象映射到cache

我们使每一个缓存节点（Shard）也遵循同样的Hash算法，比如利用IP做Hash，映射到环形空间当中，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。

### 2、容错性和扩展性

#### a. 容错性

现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。

#### b. 扩展性

往集群添加节点或从集群删除节点将改变在环的一些部分分配请求，我们称之为受影响的区间（affected range）。如果我们知道受影响区间的界限，就能够将请求移到正确的位置。如果在系统中增加一台服务器Node X，此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X 。一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。

综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。

考量 Hash 算法的一个指标是平衡性 (Balance)。

> 平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。

当一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。例如系统中只有两台服务器，造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。

### 3、虚拟节点

“虚拟节点”（ virtual node ）是实际节点在 hash 空间的复制品（ replica ），就是基于原来的物理节点映射出 N 个子节点，最后把所有的子节点映射到环形空间上。一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。引入“虚拟节点”后，映射关系就从 { 对象 -> 节点 } 转换到了 { 对象 -> 虚拟节点 } 。

### 4、实现

一致性hash算法实现有两个关键问题需要解决，一个是用于结点存储和查找的数据结构的选择，另一个是结点hash算法的选择。

首先来谈一下一致性hash算法中用于存储结点的数据结构。通过了解一致性hash的原理，我们知道结点可以想象为是存储在一个环形的数据结构上（如下图），结点A、B、C、D按hash值在环形分布上是有序的，也就是说结点可以按hash值存储在一个有序的队列里。如下图所示，当一个hash值为-2^20的请求点P查找路由结点时，一致性hash算法会按hash值的顺时针方向路由到第一个结点上（B），也就是相当于要在存储结点的有序结构中，按查询的key值找到大于key值中的最小的那个结点。因此，我们应该选择一种数据结构，它应该高效地支持结点频繁地增删，也必须具有理想的查询效率。那么，红黑树可以满足这些要求。红黑树是一颗近似平衡的一颗二叉查找树，因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。 因此，我们选择使用红黑树作为结点的存储结构，除了需要实现红黑树基本的插入、删除、查找的基本功能，我们还应该增加另一个查询lookup函数，用于查找大于key中最小的结点

下来，我们来说hash算法的选择。一致性hash算法最初提出来，就是为了解决负载均衡的问题。每个实体结点会包含很多虚拟结点，虚拟结点是平衡负载的关键。我们希望虚拟结点可以均衡的散列在整个“环”上，这样不仅可以负载到不同hash值的路由请求，还可以当某个结点down掉，原来路由到down掉结点的请求也可以较均衡的路由到其他结点而不会对某个结点造成大量的负载请求。这里，我们选择使用MD5算法。通过MD5算法，可以将一个标示串（用于标示虚拟结点）转化得到一个16字节的字符数组，再对该数组进行处理，得到一个整形的hash值。由于MD5具有高度的离散性，所以生成的hash值也会具有很大的离散性，会均衡的散列到“环”上。

hash算法具有可选择性，定义一个hash算法接口，方便以后进行其他算法的扩展。

## 三、场景

Tencent2012 笔试题附加题

```
问题描述：  例如手机朋友网有n个服务器，为了方便用户的访问会在服务器上缓存数据，因此用户每次访问的时候最好能保持同一台服务器。已有的做法是根据ServerIPIndex[QQNUM%n]得到请求的服务器，这种方法很方便将用户分到不同的服务器上去。但是如果一台服务器死掉了，那么n就变为了n-1，那么ServerIPIndex[QQNUM%n]与ServerIPIndex[QQNUM%（n-1）]基本上都不一样了，所以大多数用户的请求都会转到其他服务器，这样会发生大量访问错误。

问：  如何改进或者换一种方法，使得：

（1）一台服务器死掉后，不会造成大面积的访问错误，
（2）原有的访问基本还是停留在同一台服务器上；
（3）尽量考虑负载均衡。
```



## 四、总结

**一致性hash的特性:**

- 平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。
- 单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。
- 分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。
- 负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。

## REFERENCE

1. [Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web](http://dl.acm.org/citation.cfm?id=258660)
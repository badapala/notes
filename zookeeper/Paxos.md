

# Paxos

Paxos算法是Leslie Lamport于1990年提出的一种基于消息传递且具有高度容错特性的一致性算法， 是目前公认的解决分布式一致性问题最有效的算法之一。[P.25 - 27]

Paxos算法的核心是一个一致性算法 ，也即论文"The Part-Time Parliament"中提到 的"synod"算法。

## 问题描述：

假设有一组可以提出提案的进程集合。那么对于一个一致性算法来说需要保证以下几点：

- 在这些被提出的提案中，只有一个会被选定；
- 如果没有被提出的提案，那么就不会有被选定的提案；
- 当一个提案被选定后，进程应该可以获取被选定的提案的信息。

对于一致性来说，安全性（SAFETY：指那些需要保证永远都不会发生的事情）需求如下：

- 只有被提出的提案才可以被选定；

- 只能有一个值被选定；

- 如果某个进程认为某个提案被选了，那么这个提案必须是被选定的那个。

  活性需求（LIVENESS：指那些一定会发生的事情）：略

在该一致性算法中，有三种参与角色：Proposer、Accepter和Learner。在具体的实现中，一个进程可能充当不止一个角色，假设不同参与者之间可以通过收发消息来进行通信，那么：

- 每个参与者以任意的速度执行，可能会因为出错而停止，也可能重启。同时，即使一个提案被选定后，所有的参与者也都有可能失败或重启，因此除非那些失败或重启的参与者可以记录某些信息，否则无法确定最终的值。
- 消息在传输过程中可能会出现不可预知的延迟，也可能会重复或丢失，但是消息不会被损坏，即消息内容不会被篡改。

## 提案的选定：

在存在多个Acceptor的情况下：Proposer向一个Acceptor集合发送提案，同样，集合中的每个Acceptor都可能会批准该提案，当有足够多的Acceptor批准的时候，就可以认为这个提案被选定了。另外，我们再规定，每一个 Acceptor最多只能批准一个提案，那么就能保证只有一个提案被选定了。

## 推导过程：

在没有失败和消息丢失的情况下，如果希望即使在只有一个提案被提出的情况下，仍然可以选出一个提案，则：

**P1：一个 Acceptor 必须批准它收到的第一个提案；**

这个需求引出了另外一个问题：如果有多个提案被多个Proposer同时提出，这可能会导致虽然每个Acceptor都批准了它收到的第一个提案，但是没有一个提案是由多数人批准的；即，无法选定最终的提案。因此，在P1的基础上，再加上一个提案选定需要由半数以上的Acceptor批准的需求暗示着一个 Acceptor 必须能够批准不止一个提案。这里我们假设使用了一个全局编号来唯一标识每一个被Acceptor批准的提案，当一个具有某Value值的提案被半数以上的Acceptor批准后，我们就可以认定该Value被选定了，此时我们也认为该提案被选定了。需要注意的是，此处的提案与Value已经不是同一个概念了，提案变成了一个由编号和Value组成的组合体，因此我们以`[编号，Value]`来表示一个提案。

**P2：如果编号为M0、Value值为V0的提案（[M0, V0]）被选定了，那么所有比编号M0更高的，且被选定的提案，其Value值必须是V0；**

因为提案的编号是全序的，条件2就保证了只有一个Value值被选定 这一关键安全属性。同时，一个提案要被选定，其首先必须被至少一个 Acceptor 批准，因此我们可以通过满足如下条件来满足P2。

**P2a：如果编号为M0、Value值为V0的提案（[M0, V0]）被选定了，那么所有比编号M0更高的，且被Acceptor批准的提案，其Value值必须也是V0；**

至此，我们仍然需要P1来保证提案会被选定，但是因为通信是异步的一个提案可能会在某个Acceptor还未收到任何提案时就被选定了，但这与P2a矛盾，因此如果要同时满足P1和P2a，需要对P2a进行如下强化：

**P2b：如果一个提案[M0,V0]被选定后，那么之后任何Proposer产生的编号更高的提案，其值都为V0；**

因为一个提案必须在被Proposer提出后才能被Acceptor批准，因此P2b包含了P2a，进而包含了P2。于是，论证P2b成立即可：

**假设某个提案[M0,V0]已被选定了，证明任何编号 Mn > M0 提案，其Value值都是V0。**

## 数学归纳法证明：

**P2c：对于任意的Mn和Vn，如果提案[Mn, Vn]被提出，那么肯定存在一个由半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：**

- S中不存在任何批准过编号小于Mn的提案的Acceptor；
- 选取S中所有Acceptor批准的编号小于Mn的提案，其中编号最大的那个提案其Value值是Vn。

实际上P2c规定了每个Proposer如何产生一个提案：对于产生的每个提案[Mn, Vn]，需要满足如下条件：

> 存在一个由超过半数的Acceptor组成的集合S：
>
> - 要么S中没有Acceptor批准过编号小于Mn的任何提案；
> - 要么S中的所有Acceptor批准的所有编号小于Mn的提案中，编号最大的那个提案的Value值为Vn。

## Proposer生成提案：

在P2c的基础上如何进行提案的生成。Proposer在产生一个编号为Mn的提案时，必须要知道当前某一个将要或已经被半数以上Acceptor批准的编号小于Mn但为最大编号的提案。并且，Proposer会要求所有的Acceptor都不要再批准任何编号小于Mn的提案——这就引出了提案生成算法：

1. Proposer选择一个新的提案编号Mn，然后向某个Acceptor集合的成员发送请求，要求该集合中的Acceptor做出如下回应：

   - 向Proposer承诺，保证不再批准任何编号小于Mn的提案；
   - 如果Acceptor已经批准过任何提案，那么就向Proposer反馈当前Acceptor已经批准的编号小于Mn但为最大编号的那个提案的值。

   我们将此请求称为编号为Mn的提案的Prepare请求。

2. 如果Proposer收到了来自半数以上的Acceptor的响应结果，那么它就可以产生编号为Mn、Value值为Vn的提案，这里的Vn是所有响应中编号最大的提案的Value值。当然还存在另一种情况就是半数以上的的Acceptor都没有通过任何提案，即响应中不包含任何的提案，那么此时Vn值就可以由Proposer任意选择。

在确定提案之后，Proposer就会将提案再次发送给某个Acceptor集合，并期望获得它们的批准，我们称此请求为Accept请求。需要注意的是，此时接受Accept请求的Acceptor集合不一定是之前响应Prepare请求的Acceptor集合——任意两个半数以上的Acceptor集合必定包含至少一个公共Acceptor。

## Acceptor批准提案：

根据以上，一个 Acceptor 可能会收到来自Proposer的两种请求，分别是 Prepare 请求和 Accept 请求，对这两类请求做出响应的条件分别如下：

- Prepare 请求：Acceptor 可以在任何时候响应一个 Prepare 请求；
- Accept 请：在不违背Accept 现有承诺的前提下，可以任意响应Accept请求。

则，对Acceptor 逻辑处理的约束条件，大体可以定义如下：

**P1a：一个 Acceptor 只要示响应过任何编号大于 Mn的Prepare请求，那么 就可以接受这个Mn的提案。**

## 算法优化：

尽可能忽略Prepare请求：

> 假设一个 Acceptor 收到了一个编号为Mn的Prepare请求，但此时该Acceptor已经对编号大于Mn的Prepare请求做出了响应，因此它肯定不会再批准任何新的编号为Mn的提案，则，Acceptor就没必要对这个Prepare请求做出响，于是Acceptor可以选择忽略这样的Prepare请求。同时Acceptor也可以忽略掉那些它已经批准过的提案的Prepare请求。

通过这个优化，每个Acceptor只需记住它已经批准的提案的最大编号以及它已经做出Prepare请求响应的提案的最大编号，以便在出现故障或节点重启的情况下，也能保证P2c的不变性。对于 Proposer来说，只要它保证不生产具有相同编号的提案，那么就可以丢弃任意的提案以及它所有的运行时状态信息。

## 算法陈述：

类似于2PC的算法执行过程：

**阶段一**

1. Proposer选择一个提案编号Mn，然后 向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求。
2. 如果一个 Acceptor 收到一个编号为Mn的Prepare请求，且编号Mn大于 该 Acceptor 已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor承诺不会再生产编号小于Mn的提案。

**阶段二**

1. 如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare的响应，那么它就会发送一个针对[Mn, Vn]提案的Accept请求给Acceptor。注意，Vn的值就是收到的响应中编号最大的值，如果响应中不包含任何提案，那么它就是任意值。
2. 如果Acceptor收到这个针对[Mn, Vn]提案的Accept请求，只要该Acceptor尚未对编号大于  Mn 的Prepare请求做出响应，那么它就可以通过这个提案。

## 提案的获取：

如何让Learner获取提案：

**方案一**

Learner获取一个提案的前提是，该提案已被半数以上的Acceptor批准。则，可以使Acceptor批准了一个提案后，就将该提案发送给所有的Learner。缺点是需要Acceptor与所有的Learner逐个进行通信，通信次数较多。

**方案二**

让所有的Acceptor将它们对提案的批准情况，统一发送给一个特定的Learner（主Learner），在不考虑拜占庭将军问题的前提下，我们假定Learner之间可以通过消息通信来互相感知提案的选定情况，则，在主Learner被通知一个提案已经被选定时，它会负责通知其他Learner。优点是减少了通信次数，缺点是主Learner随时可能发生故障。

**方案三**

将方案二中的单Learner（主Learner）改进为一个Learner集合。缺点是网络通信的复杂度较高。

## 通过选取主Proposer保证算法的活性

细节。

假设存在一种极端情况，有两个Proposer依次提出了一系列编号递增的议案，但是都无法被选定，具体流程如下：

> Proposer P1提出了一个信号为M1的提案，并完成了上述阶段一的流程。但与此同时，另外一个 Proposer P2提出了一个 编号为M2(M2 > M1) 的提案，同样也完成了阶段一的流程，于是Acceptor已经承诺不再批准编号小于M2的提案了。因此当P1进入阶段二的时候，其发出的Accept请求将被Acceptor忽略，于是P1再次进入阶段一并提出了一个 编号为M3(M3 > M2) 的提案，而这又导致P2在第二阶段的Accept请求被忽略，以此类推，提案选择的过程将陷入死循环。

为了保证Paxos算法流程的可持续性，以避免上述死循环，就必须选择一个 主Proposer，并规定只有主Proposer才能提出提案。这样一来，只要主Proposer可以与过半的Acceptor能够正常通信，那么但凡主Proposer提出的提案，必将被批准。如果Proposer发现当前算法流程中已经有一个编号更大的提案被提出或正在接受批准，那么它会丢弃这个编号较小的提案，并最终能够选出一个编号足够大的提案。因此，如果系统中有足够多的组件（包括 Proposer、Acceptor 和其他网络通信组件）能够正常工作，那么通过选择一个主Proposer，整套Paxos算法流程就能保持活性。